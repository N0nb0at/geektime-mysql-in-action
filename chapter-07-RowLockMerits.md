---
title: MySQL-07-行锁功过：怎么减少行锁对性能的影响
date: 2019/04/08 01:26:29
categories: 
  - [study]
tags: 
  - [geektime]
  - [MySQL]
---

## 从两段锁说起

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这就是两段锁协议。

如果事务中要锁多个行，要把最可能造成锁冲突、做可能影响并发度的锁尽量往后放。

<!-- more -->

## 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，设计的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

当出现死锁以后，有两种策略：

- 直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。
- 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得意继续执行。将 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，如果出现死锁，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。

如果设置为一个很小的值，当出现死锁的时候，确实很快就解开了，但是如果不是死锁，而是简单地锁等待，会出现很多误伤。

所以，正常情况下还是采用第二种策略，即『主动死锁检测』，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也有额外的负担。

### 怎样解决由热点更新导致的性能问题

一种头痛医头的方法，就是如果能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，如果出现死锁，就会滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。

另一个思路是控制并发度。如果能够控制并发，比如同一行同时最多只有 10 个线程在更新，那么死锁检测的成本很低，不会出现问题。一个直接的想法就是，在客户端做并发控制。但是，很快会发现这个方法不太可行，因为客户端很多。因此，这个并发控制要坐在数据库服务端。如果有中间件，可以考虑在中间件实现；如果团队有能修改 MySQL 源码的人，也可以做在 MySQL 里。基本思路就是，对于相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。

如果团队暂时没有数据库方面的专家，不能实现这样的方案，就要考虑从设计上优化了。可以通过将一行改成逻辑上的多行来减少锁冲突。这个方案看上去是无损的，但其实这类方案需要根据业务逻辑做详细设计。
